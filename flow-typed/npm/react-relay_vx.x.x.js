// flow-typed signature: 6db60c72460b1369ff8994eac942512d
// flow-typed version: <<STUB>>/react-relay_v^1.1.0/flow_v0.49.1

/**
 * This is an autogenerated libdef stub for:
 *
 *   'react-relay'
 *
 * Fill this stub out by replacing all the `any` types.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */

 declare module 'react-relay' {
   declare type PayloadError = {
     message: string,
     locations?: Array<{
       line: number,
       column: number,
     }>,
   }

   declare type onCompleted = (response: ?Object, errors: ?Array<PayloadError>) => void
   declare type onError = (error: Error) => void

   declare type CommitOptions = {
     onCompleted: onCompleted,
     onError: onError
   }

   /**
    * Ideally this would be a union of Field/Fragment/Mutation/Query/Subscription,
    * but that causes lots of Flow errors.
    */
   declare type ConcreteBatchCallVariable = {
     jsonPath: string,
     kind: 'BatchCallVariable',
     sourceQueryID: string,
   }
   declare type ConcreteCall = {
     kind: 'Call',
     metadata: {
       type?: ?string,
     },
     name: string,
     value: ?ConcreteValue,
   }
   declare type ConcreteCallValue = {
     callValue: mixed,
     kind: 'CallValue',
   }
   declare type ConcreteCallVariable = {
     callVariableName: string,
     kind: 'CallVariable',
   }
   declare type ConcreteDirective = {
     args: Array<ConcreteDirectiveArgument>,
     kind: 'Directive',
     name: string,
   }
   declare type ConcreteDirectiveArgument = {
     name: string,
     value: ?ConcreteDirectiveValue,
   }
   declare type ConcreteDirectiveValue =
     | ConcreteCallValue
     | ConcreteCallVariable
     | Array<ConcreteCallValue | ConcreteCallVariable>
   declare type ConcreteFieldMetadata = {
     canHaveSubselections?: ?boolean,
     inferredPrimaryKey?: ?string,
     inferredRootCallName?: ?string,
     isAbstract?: boolean,
     isConnection?: boolean,
     isConnectionWithoutNodeID?: boolean,
     isFindable?: boolean,
     isGenerated?: boolean,
     isPlural?: boolean,
     isRequisite?: boolean,
   }
   declare type ConcreteFragmentMetadata = {
     isAbstract?: boolean,
     pattern?: boolean,
     plural?: boolean,
   }
   declare type ConcreteMutation = {
     calls: Array<ConcreteCall>,
     children?: ?Array<?ConcreteSelection>,
     directives?: ?Array<ConcreteDirective>,
     kind: 'Mutation',
     metadata: {
       inputType?: ?string,
     },
     name: string,
     responseType: string,
   }
   declare type ConcreteOperationMetadata = {
     inputType?: ?string,
   }
   declare type ConcreteQuery = {
     calls?: ?Array<ConcreteCall>,
     children?: ?Array<?ConcreteSelection>,
     directives?: ?Array<ConcreteDirective>,
     fieldName: string,
     isDeferred?: boolean,
     kind: 'Query',
     metadata: {
       identifyingArgName?: ?string,
       identifyingArgType?: ?string,
       isAbstract?: ?boolean,
       isPlural?: ?boolean,
     },
     name: string,
     type: string,
   }
   declare type ConcreteQueryMetadata = {
     identifyingArgName: ?string,
     identifyingArgType: ?string,
     isAbstract: ?boolean,
     isDeferred: ?boolean,
     isPlural: ?boolean,
   }
   declare type ConcreteSubscription = {
     calls: Array<ConcreteCall>,
     children?: ?Array<?ConcreteSelection>,
     directives?: ?Array<ConcreteDirective>,
     kind: 'Subscription',
     name: string,
     responseType: string,
     metadata: {
       inputType?: ?string,
     },
   }
   declare type ConcreteValue =
     | ConcreteBatchCallVariable
     | ConcreteCallValue
     | ConcreteCallVariable
     | Array<ConcreteCallValue | ConcreteCallVariable>

   /**
    * The output of a graphql-tagged fragment definition.
    */
   declare type ConcreteFragmentDefinition = {
     kind: 'FragmentDefinition',
     argumentDefinitions: Array<ConcreteArgumentDefinition>,
     node: ConcreteFragment,
   }

   declare type ConcreteLocalArgumentDefinition = {
     kind: 'LocalArgument',
     name: string,
     defaultValue: mixed,
   }

   declare type ConcreteRootArgumentDefinition = {
     kind: 'RootArgument',
     name: string,
   }

   /**
    * The output of a graphql-tagged operation definition.
    */
   declare type ConcreteOperationDefinition = {
     kind: 'OperationDefinition',
     argumentDefinitions: Array<ConcreteLocalArgumentDefinition>,
     name: string,
     operation: 'mutation' | 'query' | 'subscription',
     node: ConcreteFragment | ConcreteMutation | ConcreteSubscription,
   }

   declare type ConcreteArgument = ConcreteLiteral | ConcreteVariable
   declare type ConcreteArgumentDefinition =
     | ConcreteLocalArgument
     | ConcreteRootArgument
   /**
    * Represents a single ConcreteRoot along with metadata for processing it at
    * runtime. The persisted `id` (or `text`) can be used to fetch the query,
    * the `fragment` can be used to read the root data (masking data from child
    * fragments), and the `query` can be used to normalize server responses.
    *
    * NOTE: The use of "batch" in the name is intentional, as this wrapper around
    * the ConcreteRoot will provide a place to store multiple concrete nodes that
    * are part of the same batch, e.g. in the case of deferred nodes or
    * for streaming connections that are represented as distinct concrete roots but
    * are still conceptually tied to one source query.
    */
   declare type ConcreteBatch = {
     kind: 'Batch',
     fragment: ConcreteFragment,
     id: ?string,
     metadata: { [key: string]: mixed },
     name: string,
     query: ConcreteRoot,
     text: ?string,
   }
   declare type ConcreteCondition = {
     kind: 'Condition',
     passingValue: boolean,
     condition: string,
     selections: Array<ConcreteSelection>,
   }
   declare type ConcreteField = ConcreteScalarField | ConcreteLinkedField
   declare type ConcreteFragment = {
     argumentDefinitions: Array<ConcreteArgumentDefinition>,
     kind: 'Fragment',
     metadata: ?{ [key: string]: mixed },
     name: string,
     selections: Array<ConcreteSelection>,
     type: string,
   }
   declare type ConcreteFragmentSpread = {
     args: ?Array<ConcreteArgument>,
     kind: 'FragmentSpread',
     name: string,
   }
   declare type ConcreteHandle = ConcreteScalarHandle | ConcreteLinkedHandle
   declare type ConcreteRootArgument = {
     kind: 'RootArgument',
     name: string,
     type: ?string,
   }
   declare type ConcreteInlineFragment = {
     kind: 'InlineFragment',
     selections: Array<ConcreteSelection>,
     type: string,
   }
   declare type ConcreteLinkedField = {
     alias: ?string,
     args: ?Array<ConcreteArgument>,
     concreteType: ?string,
     kind: 'LinkedField',
     name: string,
     plural: boolean,
     selections: Array<ConcreteSelection>,
     storageKey: ?string,
   }
   declare type ConcreteLinkedHandle = {
     alias: ?string,
     args: ?Array<ConcreteArgument>,
     kind: 'LinkedHandle',
     name: string,
     handle: string,
     key: string,
     filters: ?Array<string>,
   }
   declare type ConcreteLiteral = {
     kind: 'Literal',
     name: string,
     type: ?string,
     value: mixed,
   }
   declare type ConcreteLocalArgument = {
     defaultValue: mixed,
     kind: 'LocalArgument',
     name: string,
     type: string,
   }
   declare type ConcreteNode =
     | ConcreteCondition
     | ConcreteLinkedField
     | ConcreteFragment
     | ConcreteInlineFragment
     | ConcreteRoot
   declare type ConcreteRoot = {
     argumentDefinitions: Array<ConcreteLocalArgument>,
     kind: 'Root',
     name: string,
     operation: 'mutation' | 'query' | 'subscription',
     selections: Array<ConcreteSelection>,
   }
   declare type ConcreteScalarField = {
     alias: ?string,
     args: ?Array<ConcreteArgument>,
     kind: 'ScalarField',
     name: string,
     storageKey: ?string,
   }
   declare type ConcreteScalarHandle = {
     alias: ?string,
     args: ?Array<ConcreteArgument>,
     kind: 'ScalarHandle',
     name: string,
     handle: string,
     key: string,
     filters: ?Array<string>,
   }
   declare type ConcreteSelection =
     | ConcreteCondition
     | ConcreteField
     | ConcreteFragmentSpread
     | ConcreteHandle
     | ConcreteInlineFragment
   declare type ConcreteVariable = {
     kind: 'Variable',
     name: string,
     type: ?string,
     variableName: string,
   }
   declare type ConcreteSelectableNode = ConcreteFragment | ConcreteRoot
   declare type GeneratedNode = ConcreteBatch | ConcreteFragment

   // The type of a graphql`...` tagged template expression.
   declare type GraphQLTaggedNode =
     | (() => ConcreteFragment | ConcreteBatch)
     | {
     modern: () => ConcreteFragment | ConcreteBatch,
     classic: () => ConcreteFragmentDefinition | ConcreteOperationDefinition,
   }

   declare function graphql (strings: Array<string>): GraphQLTaggedNode

   declare type GeneratedNodeMap = { [key: string]: GraphQLTaggedNode }

   declare function createFragmentContainer<TBase: ReactClass<*>> (
     Component: TBase,
     fragmentSpec: GraphQLTaggedNode | GeneratedNodeMap
   ): TBase

   declare function createPaginationContainer<TBase: ReactClass<*>> (
     Component: TBase,
     fragmentSpec: GraphQLTaggedNode | GeneratedNodeMap,
     options: any, // TODO
   ): TBase

   declare function createRefetchContainer<TBase: ReactClass<*>>(
     Component: TBase,
     fragmentSpec: GraphQLTaggedNode | GeneratedNodeMap,
     taggedNode: GraphQLTaggedNode,
   ): TBase

   declare type Variables = { [name: string]: $FlowFixMe };
   declare type DataID = string;

   declare type TEnvironment = Environment;
   declare type TFragment = ConcreteFragment;
   declare type TGraphQLTaggedNode = GraphQLTaggedNode;
   declare type TNode = ConcreteSelectableNode;
   declare type TOperation = ConcreteBatch;
   declare type TPayload = RelayResponsePayload;

   declare type FragmentMap = CFragmentMap<TFragment>;
   declare type OperationSelector = COperationSelector<TNode, TOperation>;
   declare type RelayContext = CRelayContext<TEnvironment>;
   declare type Selector = CSelector<TNode>;
   declare type TSnapshot<TRecord> = CSnapshot<TNode, TRecord>;
   declare type Snapshot = TSnapshot<Record>;
   declare type ProxySnapshot = TSnapshot<RecordProxy>;
   declare type UnstableEnvironmentCore = CUnstableEnvironmentCore<TEnvironment,
     TFragment,
     TGraphQLTaggedNode,
     TNode,
     TOperation,
     >;

   declare interface IRecordSource<TRecord> {
     get(dataID: DataID): ?TRecord,
   }

   /**
    * A read-only interface for accessing cached graph data.
    */
   declare interface RecordSource extends IRecordSource<Record> {
     get(dataID: DataID): ?Record,

     getRecordIDs(): Array<DataID>,

     getStatus(dataID: DataID): RecordState,

     has(dataID: DataID): boolean,

     load(dataID: DataID,
          callback: (error: ?Error, record: ?Record) => void,): void,

     size(): number,
   }

   /**
    * A read/write interface for accessing and updating graph data.
    */
   declare interface MutableRecordSource extends RecordSource {
     clear(): void,

     delete(dataID: DataID): void,

     remove(dataID: DataID): void,

     set(dataID: DataID, record: Record): void,
   }

   /**
    * An interface for keeping multiple views of data consistent across an
    * application.
    */
   declare interface Store {
     /**
      * Get a read-only view of the store's internal RecordSource.
      */
     getSource(): RecordSource,

     /**
      * Determine if the selector can be resolved with data in the store (i.e. no
      * fields are missing).
      */
     check(selector: Selector): boolean,

     /**
      * Read the results of a selector from in-memory records in the store.
      */
     lookup(selector: Selector): Snapshot,

     /**
      * Notify subscribers (see `subscribe`) of any data that was published
      * (`publish()`) since the last time `notify` was called.
      */
     notify(): void,

     /**
      * Publish new information (e.g. from the network) to the store, updating its
      * internal record source. Subscribers are not immediately notified - this
      * occurs when `notify()` is called.
      */
     publish(source: RecordSource): void,

     /**
      * Attempts to load all the records necessary to fulfill the selector into the
      * target record source.
      */
     resolve(target: MutableRecordSource,
             selector: Selector,
             callback: AsyncLoadCallback,): void,

     /**
      * Ensure that all the records necessary to fulfill the given selector are
      * retained in-memory. The records will not be eligible for garbage collection
      * until the returned reference is disposed.
      */
     retain(selector: Selector): Disposable,

     /**
      * Subscribe to changes to the results of a selector. The callback is called
      * when `notify()` is called *and* records have been published that affect the
      * selector results relative to the last `notify()`.
      */
     subscribe(snapshot: Snapshot,
               callback: (snapshot: Snapshot) => void,): Disposable,
   }

   /**
    * An interface for imperatively getting/setting properties of a `Record`. This interface
    * is designed to allow the appearance of direct Record manipulation while
    * allowing different implementations that may e.g. create a changeset of
    * the modifications.
    */
   declare interface RecordProxy {
     copyFieldsFrom(source: RecordProxy): void,

     getDataID(): DataID,

     getLinkedRecord(name: string, args

     ?: ?
     Variables
     ): ?
     RecordProxy,

     getLinkedRecords(name: string, args

     ?: ?
     Variables
     ): ?

     Array<?

     RecordProxy
     >,

     getOrCreateLinkedRecord(name: string,
                             typeName: string,
                             args

     ?: ?
     Variables,
     ):
     RecordProxy,

     getType(): string,

     getValue(name: string, args

     ?: ?
     Variables
     ):
     mixed,

     setLinkedRecord(record: RecordProxy,
                     name: string,
                     args

     ?: ?
     Variables,
     ):
     RecordProxy,

     setLinkedRecords(records: Array<?RecordProxy>,
                      name: string,
                      args

     ?: ?
     Variables,
     ):
     RecordProxy,

     setValue(value: mixed, name: string, args

     ?: ?
     Variables
     ):
     RecordProxy,
   }

   /**
    * An interface for imperatively getting/setting properties of a `RecordSource`. This interface
    * is designed to allow the appearance of direct RecordSource manipulation while
    * allowing different implementations that may e.g. create a changeset of
    * the modifications.
    */
   declare interface RecordSourceProxy extends IRecordSource<RecordProxy> {
     create(dataID: DataID, typeName: string): RecordProxy,

     delete(dataID: DataID): void,

     get(dataID: DataID): ?RecordProxy,

     getRoot(): RecordProxy,
   }

   /**
    * Extends the RecordSourceProxy interface with methods for accessing the root
    * fields of a Selector.
    */
   declare interface RecordSourceSelectorProxy extends IRecordSource<RecordProxy> {
     create(dataID: DataID, typeName: string): RecordProxy,

     delete(dataID: DataID): void,

     get(dataID: DataID): ?RecordProxy,

     getRoot(): RecordProxy,

     getRootField(fieldName: string): ?RecordProxy,

     getPluralRootField(fieldName: string): ?Array<?RecordProxy>,

     getResponse(): ?Object,
   }

   declare interface IRecordReader<TRecord> {
     getDataID(record: TRecord): DataID,

     getType(record: TRecord): string,

     getValue(record: TRecord, name: string, args

     ?: ?
     Variables
     ):
     mixed,

     getLinkedRecordID(record: TRecord, name: string, args

     ?: ?
     Variables
     ): ?
     DataID,

     getLinkedRecordIDs(record: TRecord,
                        name: string,
                        args

     ?: ?
     Variables,
     ): ?

     Array<?

     DataID
     >,
   }

   /**
    * Settings for how a query response may be cached.
    *
    * - `force`: causes a query to be issued unconditionally, irrespective of the
    *   state of any configured response cache.
    * - `poll`: causes a query to live update by polling at the specified interval
    in milliseconds. (This value will be passed to setTimeout.)
    */
   declare type CacheConfig = {
     force?: ?boolean,
     poll?: ?number,
   };

   /**
    * Represents any resource that must be explicitly disposed of. The most common
    * use-case is as a return value for subscriptions, where calling `dispose()`
    * would cancel the subscription.
    */
   declare type Disposable = {
     dispose(): void,
   };

   /**
    * Arbitrary data e.g. received by a container as props.
    */
   declare type Props = { [key: string]: mixed };

   /*
    * An individual cached graph object.
    */
   declare type Record = { [key: string]: mixed };

   /**
    * A collection of records keyed by id.
    */
   declare type RecordMap<T> = { [dataID: DataID]: ?T };

   /**
    * A selector defines the starting point for a traversal into the graph for the
    * purposes of targeting a subgraph.
    */
   declare type CSelector<TNode> = {
     dataID: DataID,
     node: TNode,
     variables: Variables,
   };

   /**
    * A representation of a selector and its results at a particular point in time.
    */
   declare type CSnapshot<TNode, TRecord> = CSelector<TNode> & {
     data: ?SelectorData,
     seenRecords: RecordMap<TRecord>,
   };

   /**
    * The results of a selector given a store/RecordSource.
    */
   declare type SelectorData = { [key: string]: mixed };

   /**
    * The results of reading the results of a FragmentMap given some input
    * `Props`.
    */
   declare type FragmentSpecResults = { [key: string]: mixed };

   /**
    * A utility for resolving and subscribing to the results of a fragment spec
    * (key -> fragment mapping) given some "props" that determine the root ID
    * and variables to use when reading each fragment. When props are changed via
    * `setProps()`, the resolver will update its results and subscriptions
    * accordingly. Internally, the resolver:
    * - Converts the fragment map & props map into a map of `Selector`s.
    * - Removes any resolvers for any props that became null.
    * - Creates resolvers for any props that became non-null.
    * - Updates resolvers with the latest props.
    */
   declare interface FragmentSpecResolver {
     /**
      * Stop watching for changes to the results of the fragments.
      */
     dispose(): void,

     /**
      * Get the current results.
      */
     resolve(): FragmentSpecResults,

     /**
      * Update the resolver with new inputs. Call `resolve()` to get the updated
      * results.
      */
     setProps(props: Props): void,

     /**
      * Override the variables used to read the results of the fragments. Call
      * `resolve()` to get the updated results.
      */
     setVariables(variables: Variables): void,
   }

   declare type CFragmentMap<TFragment> = { [key: string]: TFragment };

   /**
    * An operation selector describes a specific instance of a GraphQL operation
    * with variables applied.
    *
    * - `root`: a selector intended for processing server results or retaining
    *   response data in the store.
    * - `fragment`: a selector intended for use in reading or subscribing to
    *   the results of the the operation.
    */
   declare type COperationSelector<TNode, TOperation> = {
     fragment: CSelector<TNode>,
     node: TOperation,
     root: CSelector<TNode>,
     variables: Variables,
   };

   /**
    * The public API of Relay core. Represents an encapsulated environment with its
    * own in-memory cache.
    */
   declare interface CEnvironment<
   TEnvironment,
   TFragment,
   TGraphQLTaggedNode,
   TNode,
   TOperation,
   TPayload,
   > {
     /**
      * Read the results of a selector from in-memory records in the store.
      */
     lookup(selector: CSelector<TNode>): CSnapshot<TNode, Record>,

     /**
      * Subscribe to changes to the results of a selector. The callback is called
      * when data has been committed to the store that would cause the results of
      * the snapshot's selector to change.
      */
     subscribe(snapshot: CSnapshot<TNode, Record>,
               callback: (snapshot: CSnapshot<TNode, Record>) => void,): Disposable,

     /**
      * Ensure that all the records necessary to fulfill the given selector are
      * retained in-memory. The records will not be eligible for garbage collection
      * until the returned reference is disposed.
      *
      * Note: This is a no-op in the classic core.
      */
     retain(selector: CSelector<TNode>): Disposable,

     /**
      * Send a query to the server with request/response semantics: the query will
      * either complete successfully (calling `onNext` and `onCompleted`) or fail
      * (calling `onError`).
      *
      * Note: Most applications should use `streamQuery` in order to
      * optionally receive updated information over time, should that feature be
      * supported by the network/server. A good rule of thumb is to use this method
      * if you would otherwise immediately dispose the `streamQuery()`
      * after receving the first `onNext` result.
      */
     sendQuery(config: {|
       cacheConfig?: ?CacheConfig,
       onCompleted?: ?() => void,
       onError?: ?(error: Error) => void,
       onNext?: ?(payload: TPayload) => void,
       operation: COperationSelector<TNode, TOperation>,
     |}): Disposable,

     /**
      * Send a query to the server with request/subscription semantics: one or more
      * responses may be returned (via `onNext`) over time followed by either
      * the request completing (`onCompleted`) or an error (`onError`).
      *
      * Networks/servers that support subscriptions may choose to hold the
      * subscription open indefinitely such that `onCompleted` is not called.
      */
     streamQuery(config: {|
       cacheConfig?: ?CacheConfig,
       onCompleted?: ?() => void,
       onError?: ?(error: Error) => void,
       onNext?: ?(payload: TPayload) => void,
       operation: COperationSelector<TNode, TOperation>,
     |}): Disposable,

     unstable_internal: CUnstableEnvironmentCore<TEnvironment,
       TFragment,
       TGraphQLTaggedNode,
       TNode,
       TOperation,
       >,
   }

   declare interface CUnstableEnvironmentCore<
   TEnvironment,
   TFragment,
   TGraphQLTaggedNode,
   TNode,
   TOperation,
   > {
     /**
      * Create an instance of a FragmentSpecResolver.
      *
      * TODO: The FragmentSpecResolver *can* be implemented via the other methods
      * defined here, so this could be moved out of core. It's convenient to have
      * separate implementations until the experimental core is in OSS.
      */
     createFragmentSpecResolver: (context: CRelayContext<TEnvironment>,
                                  fragments: CFragmentMap<TFragment>,
                                  props: Props,
                                  callback: () => void,) => FragmentSpecResolver,

     /**
      * Creates an instance of an OperationSelector given an operation definition
      * (see `getOperation`) and the variables to apply. The input variables are
      * filtered to exclude variables that do not matche defined arguments on the
      * operation, and default values are populated for null values.
      */
     createOperationSelector: (operation: TOperation,
                               variables: Variables,) => COperationSelector<TNode, TOperation>,

     /**
      * Given a graphql`...` tagged template, extract a fragment definition usable
      * by this version of Relay core. Throws if the value is not a fragment.
      */
     getFragment: (node: TGraphQLTaggedNode) => TFragment,

     /**
      * Given a graphql`...` tagged template, extract an operation definition
      * usable by this version of Relay core. Throws if the value is not an
      * operation.
      */
     getOperation: (node: TGraphQLTaggedNode) => TOperation,

     /**
      * Determine if two selectors are equal (represent the same selection). Note
      * that this function returns `false` when the two queries/fragments are
      * different objects, even if they select the same fields.
      */
     areEqualSelectors: (a: CSelector<TNode>, b: CSelector<TNode>) => boolean,

     /**
      * Given the result `item` from a parent that fetched `fragment`, creates a
      * selector that can be used to read the results of that fragment for that item.
      *
      * Example:
      *
      * Given two fragments as follows:
      *
      * ```
      * fragment Parent on User {
    *   id
    *   ...Child
    * }
      * fragment Child on User {
    *   name
    * }
      * ```
      *
      * And given some object `parent` that is the results of `Parent` for id "4",
      * the results of `Child` can be accessed by first getting a selector and then
      * using that selector to `lookup()` the results against the environment:
      *
      * ```
      * const childSelector = getSelector(queryVariables, Child, parent);
      * const childData = environment.lookup(childSelector).data;
      * ```
      */
     getSelector: (operationVariables: Variables,
                   fragment: TFragment,
                   prop: mixed,) => ?CSelector<TNode>,

     /**
      * Given the result `items` from a parent that fetched `fragment`, creates a
      * selector that can be used to read the results of that fragment on those
      * items. This is similar to `getSelector` but for "plural" fragments that
      * expect an array of results and therefore return an array of selectors.
      */
     getSelectorList: (operationVariables: Variables,
                       fragment: TFragment,
                       props: Array<mixed>,) => ?Array<CSelector<TNode>>,

     /**
      * Given a mapping of keys -> results and a mapping of keys -> fragments,
      * extracts the selectors for those fragments from the results.
      *
      * The canonical use-case for this function are Relay Containers, which
      * use this function to convert (props, fragments) into selectors so that they
      * can read the results to pass to the inner component.
      */
     getSelectorsFromObject: (operationVariables: Variables,
                              fragments: CFragmentMap<TFragment>,
                              props: Props,) => { [key: string]: ?(CSelector<TNode> | Array<CSelector<TNode>>) },

     /**
      * Given a mapping of keys -> results and a mapping of keys -> fragments,
      * extracts a mapping of keys -> id(s) of the results.
      *
      * Similar to `getSelectorsFromObject()`, this function can be useful in
      * determining the "identity" of the props passed to a component.
      */
     getDataIDsFromObject: (fragments: CFragmentMap<TFragment>,
                            props: Props,) => { [key: string]: ?(DataID | Array<DataID>) },

     /**
      * Given a mapping of keys -> results and a mapping of keys -> fragments,
      * extracts the merged variables that would be in scope for those
      * fragments/results.
      *
      * This can be useful in determing what varaibles were used to fetch the data
      * for a Relay container, for example.
      */
     getVariablesFromObject: (operationVariables: Variables,
                              fragments: CFragmentMap<TFragment>,
                              props: Props,) => Variables,
   }

   /**
    * The type of the `relay` property set on React context by the React/Relay
    * integration layer (e.g. QueryRenderer, FragmentContainer, etc).
    */
   declare type CRelayContext<TEnvironment> = {
     environment: TEnvironment,
     variables: Variables,
   };

   /**
    * The public API of Relay core. Represents an encapsulated environment with its
    * own in-memory cache.
    */
   declare interface Environment
     extends CEnvironment

 <
   TEnvironment,
     TFragment,
     TGraphQLTaggedNode,
     TNode,
     TOperation,
     TPayload,
 >
   {
     /**
      * Apply an optimistic update to the environment. The mutation can be reverted
      * by calling `dispose()` on the returned value.
      */
     applyUpdate(updater
   :
     StoreUpdater
   ):
     Disposable,

       /**
        * Determine if the selector can be resolved with data in the store (i.e. no
        * fields are missing).
        *
        * Note that this operation effectively "executes" the selector against the
        * cache and therefore takes time proportional to the size/complexity of the
        * selector.
        */
       check(selector
   :
     Selector
   ):
     boolean,

       /**
        * Commit an updater to the environment. This mutation cannot be reverted and
        * should therefore not be used for optimistic updates. This is mainly
        * intended for updating fields from client schema extensions.
        */
       commitUpdate(updater
   :
     StoreUpdater
   ):
     void,

       /**
        * Get the environment's internal Store.
        */
       getStore()
   :
     Store,

       /**
        * Send a mutation to the server. If provided, the optimistic updater is
        * executed immediately and reverted atomically when the server payload is
        * committed.
        */
       sendMutation(config
   : {|
     onCompleted ? : ? (errors: ?Array<PayloadError>) => void,
       onError ? : ? (error: Error) => void,
       operation
   :
     OperationSelector,
       optimisticResponse ? : ? () => Object,
       optimisticUpdater ? : ? SelectorStoreUpdater,
       updater ? : ? SelectorStoreUpdater,
       uploadables ? : UploadableMap,
   |}):
     Disposable,

       /**
        * Send a (GraphQL) subscription to the server. Whenever there is a push from
        * the server, commit the update to the environment.
        */
       sendSubscription(config
   : {|
     onCompleted ? : ? (errors: ?Array<PayloadError>) => void,
       onNext ? : ? (payload: RelayResponsePayload) => void,
       onError ? : ? (error: Error) => void,
       operation
   :
     OperationSelector,
       updater ? : ? SelectorStoreUpdater,
   |}):
     Disposable,
   }

   declare type Observer<T> = {
     onCompleted?: ?() => void,
     onError?: ?(error: Error) => void,
     onNext?: ?(data: T) => void,
   };

   /**
    * The results of reading data for a fragment. This is similar to a `Selector`,
    * but references the (fragment) node by name rather than by value.
    */
   declare type FragmentPointer = {
     __id: DataID,
     __fragments: { [fragmentName: string]: Variables },
   };

   /**
    * A callback for resolving a Selector from a source.
    */
   declare type AsyncLoadCallback = (loadingState: LoadingState) => void;
   declare type LoadingState = $Exact<{
     status: 'aborted' | 'complete' | 'error' | 'missing',
     error?: Error,
   }>;

   /**
    * A map of records affected by an update operation.
    */
   declare type UpdatedRecords = { [dataID: DataID]: boolean };

   /**
    * A function that updates a store (via a proxy) given the results of a "handle"
    * field payload.
    */
   declare type Handler = {
     update: (store: RecordSourceProxy, fieldPayload: HandleFieldPayload) => void,
   };

   /**
    * A payload that is used to initialize or update a "handle" field with
    * information from the server.
    */
   declare type HandleFieldPayload = $Exact<{
     // The arguments that were fetched.
     args: Variables,
     // The __id of the record containing the source/handle field.
     dataID: DataID,
     // The (storage) key at which the original server data was written.
     fieldKey: string,
     // The name of the handle.
     handle: string,
     // The (storage) key at which the handle's data should be written by the
     // handler.
     handleKey: string,
   }>;

   /**
    * A function that receives a proxy over the store and may trigger side-effects
    * (indirectly) by calling `set*` methods on the store or its record proxies.
    */
   declare type StoreUpdater = (store: RecordSourceProxy) => void;

   /**
    * Similar to StoreUpdater, but accepts a proxy tied to a specific selector in
    * order to easily access the root fields of a query/mutation.
    */
   declare type SelectorStoreUpdater = (store: RecordSourceSelectorProxy) => void;

   declare function commitMutation (environment: Environment,
                                           config: MutationConfig,): Disposable

   declare class QueryRenderer extends React$Component {
     props: {
       cacheConfig?: ?CacheConfig,
       environment: Environment | ClassicEnvironment,
       query: ?GraphQLTaggedNode,
       render: (readyState: ReadyState, prevState: ?ReadyState) => ?React$Element<*>,
       variables: Variables,
     };
   }
 }

/**
 * We include stubs for each file inside this npm package in case you need to
 * require those files directly. Feel free to delete any files that aren't
 * needed.
 */
declare module 'react-relay/classic' {
  declare module.exports: any;
}

declare module 'react-relay/compat' {
  declare module.exports: any;
}

declare module 'react-relay/lib/assertFragmentMap' {
  declare module.exports: any;
}

declare module 'react-relay/lib/buildReactRelayContainer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/buildRQL' {
  declare module.exports: any;
}

declare module 'react-relay/lib/callsFromGraphQL' {
  declare module.exports: any;
}

declare module 'react-relay/lib/callsToGraphQL' {
  declare module.exports: any;
}

declare module 'react-relay/lib/checkRelayQueryData' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ConcreteQuery' {
  declare module.exports: any;
}

declare module 'react-relay/lib/containsRelayQueryRootCall' {
  declare module.exports: any;
}

declare module 'react-relay/lib/createRelayQuery' {
  declare module.exports: any;
}

declare module 'react-relay/lib/dedent' {
  declare module.exports: any;
}

declare module 'react-relay/lib/deepFreeze' {
  declare module.exports: any;
}

declare module 'react-relay/lib/diffRelayQuery' {
  declare module.exports: any;
}

declare module 'react-relay/lib/directivesToGraphQL' {
  declare module.exports: any;
}

declare module 'react-relay/lib/filterExclusiveKeys' {
  declare module.exports: any;
}

declare module 'react-relay/lib/filterRelayQuery' {
  declare module.exports: any;
}

declare module 'react-relay/lib/findRelayQueryLeaves' {
  declare module.exports: any;
}

declare module 'react-relay/lib/flattenRelayQuery' {
  declare module.exports: any;
}

declare module 'react-relay/lib/flattenSplitRelayQueries' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ForceRelayClassicContext' {
  declare module.exports: any;
}

declare module 'react-relay/lib/forEachRootCallArg' {
  declare module.exports: any;
}

declare module 'react-relay/lib/formatStorageKey' {
  declare module.exports: any;
}

declare module 'react-relay/lib/fromGraphQL' {
  declare module.exports: any;
}

declare module 'react-relay/lib/generateClientEdgeID' {
  declare module.exports: any;
}

declare module 'react-relay/lib/generateClientID' {
  declare module.exports: any;
}

declare module 'react-relay/lib/generateConcreteFragmentID' {
  declare module.exports: any;
}

declare module 'react-relay/lib/generateForceIndex' {
  declare module.exports: any;
}

declare module 'react-relay/lib/generateRQLFieldAlias' {
  declare module.exports: any;
}

declare module 'react-relay/lib/getRangeBehavior' {
  declare module.exports: any;
}

declare module 'react-relay/lib/getRelayHandleKey' {
  declare module.exports: any;
}

declare module 'react-relay/lib/getRelayQueries' {
  declare module.exports: any;
}

declare module 'react-relay/lib/GraphQLMutatorConstants' {
  declare module.exports: any;
}

declare module 'react-relay/lib/GraphQLQueryRunner' {
  declare module.exports: any;
}

declare module 'react-relay/lib/GraphQLRange' {
  declare module.exports: any;
}

declare module 'react-relay/lib/GraphQLSegment' {
  declare module.exports: any;
}

declare module 'react-relay/lib/GraphQLStoreChangeEmitter' {
  declare module.exports: any;
}

declare module 'react-relay/lib/GraphQLStoreQueryResolver' {
  declare module.exports: any;
}

declare module 'react-relay/lib/GraphQLStoreRangeUtils' {
  declare module.exports: any;
}

declare module 'react-relay/lib/intersectRelayQuery' {
  declare module.exports: any;
}

declare module 'react-relay/lib/isClassicRelayContext' {
  declare module.exports: any;
}

declare module 'react-relay/lib/isClassicRelayEnvironment' {
  declare module.exports: any;
}

declare module 'react-relay/lib/isCompatibleRelayFragmentType' {
  declare module.exports: any;
}

declare module 'react-relay/lib/isPromise' {
  declare module.exports: any;
}

declare module 'react-relay/lib/isRelayContainer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/isRelayContext' {
  declare module.exports: any;
}

declare module 'react-relay/lib/isRelayEnvironment' {
  declare module.exports: any;
}

declare module 'react-relay/lib/isRelayModernContext' {
  declare module.exports: any;
}

declare module 'react-relay/lib/isRelayVariables' {
  declare module.exports: any;
}

declare module 'react-relay/lib/isScalarAndEqual' {
  declare module.exports: any;
}

declare module 'react-relay/lib/prettyStringify' {
  declare module.exports: any;
}

declare module 'react-relay/lib/printRelayOSSQuery' {
  declare module.exports: any;
}

declare module 'react-relay/lib/printRelayQuery' {
  declare module.exports: any;
}

declare module 'react-relay/lib/QueryBuilder' {
  declare module.exports: any;
}

declare module 'react-relay/lib/rangeOperationToMetadataKey' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ReactRelayClassicExports' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ReactRelayCompatContainerBuilder' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ReactRelayCompatPublic' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ReactRelayContainerProfiler' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ReactRelayFragmentContainer-flowtest' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ReactRelayFragmentContainer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ReactRelayFragmentMockRenderer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ReactRelayPaginationContainer-flowtest' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ReactRelayPaginationContainer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ReactRelayPropTypes' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ReactRelayPublic' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ReactRelayQueryRenderer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ReactRelayRefetchContainer-flowtest' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ReactRelayRefetchContainer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/ReactRelayTypes' {
  declare module.exports: any;
}

declare module 'react-relay/lib/readRelayQueryData' {
  declare module.exports: any;
}

declare module 'react-relay/lib/recycleNodesInto' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayCacheProcessor' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayChangeTracker' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayClassicCore' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayClassicRecordState' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayCombinedEnvironmentTypes' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayCompatContainer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayCompatEnvironment' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayCompatMutations' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayCompatPaginationContainer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayCompatRefetchContainer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayCompatTypes' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayConcreteNode' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayConnectionInterface' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayContainer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayContainerComparators' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayContainerProxy' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayContainerUtils' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayDefaultHandleKey' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayDefaultNetworkLayer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayEnvironment' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayEnvironmentSerializer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayEnvironmentTypes' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayError' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayEventStatus' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayFetchMode' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayFragmentPointer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayFragmentReference' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayFragmentSpecResolver' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayGarbageCollection' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayGarbageCollector' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayGraphQLMutation' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayGraphQLTag' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayInternals' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayInternalTypes' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayMetaRoute' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayMetricsRecorder' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayMockRenderer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayMutation' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayMutationDebugPrinter' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayMutationQuery' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayMutationQueue' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayMutationRequest' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayMutationTracker' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayMutationTransaction' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayMutationTransactionStatus' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayMutationType' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayNetworkDebug' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayNetworkLayer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayNodeInterface' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayOperationSelector' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayOptimisticMutationUtils' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayOSSConnectionInterface' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayPendingQueryTracker' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayProfiler' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayPropTypes' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayPublic' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayQL' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayQuery' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayQueryCaching' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayQueryConfig' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayQueryPath' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayQueryRequest' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayQueryResultObservable' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayQueryTracker' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayQueryTransform' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayQueryVisitor' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayQueryWriter' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayReadyState' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayReadyStateRenderer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayRecord' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayRecordStatusMap' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayRecordStore' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayRecordWriter' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayRefQueryDescriptor' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayRenderer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayRootContainer' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayRoute' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayRouteFragment' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelaySelector' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayShallowMock' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayStore' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayStoreConstants' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayStoreData' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayTaskQueue' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayTypes' {
  declare module.exports: any;
}

declare module 'react-relay/lib/relayUnstableBatchedUpdates' {
  declare module.exports: any;
}

declare module 'react-relay/lib/relayUnstableBatchedUpdates.native' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayVariable' {
  declare module.exports: any;
}

declare module 'react-relay/lib/RelayVariables' {
  declare module.exports: any;
}

declare module 'react-relay/lib/restoreRelayCacheData' {
  declare module.exports: any;
}

declare module 'react-relay/lib/serializeRelayQueryCall' {
  declare module.exports: any;
}

declare module 'react-relay/lib/simpleClone' {
  declare module.exports: any;
}

declare module 'react-relay/lib/splitDeferredRelayQueries' {
  declare module.exports: any;
}

declare module 'react-relay/lib/stableJSONStringify' {
  declare module.exports: any;
}

declare module 'react-relay/lib/stableStringify' {
  declare module.exports: any;
}

declare module 'react-relay/lib/testEditDistance' {
  declare module.exports: any;
}

declare module 'react-relay/lib/throwFailedPromise' {
  declare module.exports: any;
}

declare module 'react-relay/lib/toGraphQL' {
  declare module.exports: any;
}

declare module 'react-relay/lib/transformRelayQueryPayload' {
  declare module.exports: any;
}

declare module 'react-relay/lib/validateMutationConfig' {
  declare module.exports: any;
}

declare module 'react-relay/lib/validateRelayReadQuery' {
  declare module.exports: any;
}

declare module 'react-relay/lib/writeRelayQueryPayload' {
  declare module.exports: any;
}

declare module 'react-relay/lib/writeRelayUpdatePayload' {
  declare module.exports: any;
}

declare module 'react-relay/react-relay-classic' {
  declare module.exports: any;
}

declare module 'react-relay/react-relay-classic.min' {
  declare module.exports: any;
}

declare module 'react-relay/react-relay-compat' {
  declare module.exports: any;
}

declare module 'react-relay/react-relay-compat.min' {
  declare module.exports: any;
}

declare module 'react-relay/react-relay' {
  declare module.exports: any;
}

declare module 'react-relay/react-relay.min' {
  declare module.exports: any;
}

// Filename aliases
declare module 'react-relay/classic.js' {
  declare module.exports: $Exports<'react-relay/classic'>;
}
declare module 'react-relay/compat.js' {
  declare module.exports: $Exports<'react-relay/compat'>;
}
declare module 'react-relay/index' {
  declare module.exports: $Exports<'react-relay'>;
}
declare module 'react-relay/index.js' {
  declare module.exports: $Exports<'react-relay'>;
}
declare module 'react-relay/lib/assertFragmentMap.js' {
  declare module.exports: $Exports<'react-relay/lib/assertFragmentMap'>;
}
declare module 'react-relay/lib/buildReactRelayContainer.js' {
  declare module.exports: $Exports<'react-relay/lib/buildReactRelayContainer'>;
}
declare module 'react-relay/lib/buildRQL.js' {
  declare module.exports: $Exports<'react-relay/lib/buildRQL'>;
}
declare module 'react-relay/lib/callsFromGraphQL.js' {
  declare module.exports: $Exports<'react-relay/lib/callsFromGraphQL'>;
}
declare module 'react-relay/lib/callsToGraphQL.js' {
  declare module.exports: $Exports<'react-relay/lib/callsToGraphQL'>;
}
declare module 'react-relay/lib/checkRelayQueryData.js' {
  declare module.exports: $Exports<'react-relay/lib/checkRelayQueryData'>;
}
declare module 'react-relay/lib/ConcreteQuery.js' {
  declare module.exports: $Exports<'react-relay/lib/ConcreteQuery'>;
}
declare module 'react-relay/lib/containsRelayQueryRootCall.js' {
  declare module.exports: $Exports<'react-relay/lib/containsRelayQueryRootCall'>;
}
declare module 'react-relay/lib/createRelayQuery.js' {
  declare module.exports: $Exports<'react-relay/lib/createRelayQuery'>;
}
declare module 'react-relay/lib/dedent.js' {
  declare module.exports: $Exports<'react-relay/lib/dedent'>;
}
declare module 'react-relay/lib/deepFreeze.js' {
  declare module.exports: $Exports<'react-relay/lib/deepFreeze'>;
}
declare module 'react-relay/lib/diffRelayQuery.js' {
  declare module.exports: $Exports<'react-relay/lib/diffRelayQuery'>;
}
declare module 'react-relay/lib/directivesToGraphQL.js' {
  declare module.exports: $Exports<'react-relay/lib/directivesToGraphQL'>;
}
declare module 'react-relay/lib/filterExclusiveKeys.js' {
  declare module.exports: $Exports<'react-relay/lib/filterExclusiveKeys'>;
}
declare module 'react-relay/lib/filterRelayQuery.js' {
  declare module.exports: $Exports<'react-relay/lib/filterRelayQuery'>;
}
declare module 'react-relay/lib/findRelayQueryLeaves.js' {
  declare module.exports: $Exports<'react-relay/lib/findRelayQueryLeaves'>;
}
declare module 'react-relay/lib/flattenRelayQuery.js' {
  declare module.exports: $Exports<'react-relay/lib/flattenRelayQuery'>;
}
declare module 'react-relay/lib/flattenSplitRelayQueries.js' {
  declare module.exports: $Exports<'react-relay/lib/flattenSplitRelayQueries'>;
}
declare module 'react-relay/lib/ForceRelayClassicContext.js' {
  declare module.exports: $Exports<'react-relay/lib/ForceRelayClassicContext'>;
}
declare module 'react-relay/lib/forEachRootCallArg.js' {
  declare module.exports: $Exports<'react-relay/lib/forEachRootCallArg'>;
}
declare module 'react-relay/lib/formatStorageKey.js' {
  declare module.exports: $Exports<'react-relay/lib/formatStorageKey'>;
}
declare module 'react-relay/lib/fromGraphQL.js' {
  declare module.exports: $Exports<'react-relay/lib/fromGraphQL'>;
}
declare module 'react-relay/lib/generateClientEdgeID.js' {
  declare module.exports: $Exports<'react-relay/lib/generateClientEdgeID'>;
}
declare module 'react-relay/lib/generateClientID.js' {
  declare module.exports: $Exports<'react-relay/lib/generateClientID'>;
}
declare module 'react-relay/lib/generateConcreteFragmentID.js' {
  declare module.exports: $Exports<'react-relay/lib/generateConcreteFragmentID'>;
}
declare module 'react-relay/lib/generateForceIndex.js' {
  declare module.exports: $Exports<'react-relay/lib/generateForceIndex'>;
}
declare module 'react-relay/lib/generateRQLFieldAlias.js' {
  declare module.exports: $Exports<'react-relay/lib/generateRQLFieldAlias'>;
}
declare module 'react-relay/lib/getRangeBehavior.js' {
  declare module.exports: $Exports<'react-relay/lib/getRangeBehavior'>;
}
declare module 'react-relay/lib/getRelayHandleKey.js' {
  declare module.exports: $Exports<'react-relay/lib/getRelayHandleKey'>;
}
declare module 'react-relay/lib/getRelayQueries.js' {
  declare module.exports: $Exports<'react-relay/lib/getRelayQueries'>;
}
declare module 'react-relay/lib/GraphQLMutatorConstants.js' {
  declare module.exports: $Exports<'react-relay/lib/GraphQLMutatorConstants'>;
}
declare module 'react-relay/lib/GraphQLQueryRunner.js' {
  declare module.exports: $Exports<'react-relay/lib/GraphQLQueryRunner'>;
}
declare module 'react-relay/lib/GraphQLRange.js' {
  declare module.exports: $Exports<'react-relay/lib/GraphQLRange'>;
}
declare module 'react-relay/lib/GraphQLSegment.js' {
  declare module.exports: $Exports<'react-relay/lib/GraphQLSegment'>;
}
declare module 'react-relay/lib/GraphQLStoreChangeEmitter.js' {
  declare module.exports: $Exports<'react-relay/lib/GraphQLStoreChangeEmitter'>;
}
declare module 'react-relay/lib/GraphQLStoreQueryResolver.js' {
  declare module.exports: $Exports<'react-relay/lib/GraphQLStoreQueryResolver'>;
}
declare module 'react-relay/lib/GraphQLStoreRangeUtils.js' {
  declare module.exports: $Exports<'react-relay/lib/GraphQLStoreRangeUtils'>;
}
declare module 'react-relay/lib/intersectRelayQuery.js' {
  declare module.exports: $Exports<'react-relay/lib/intersectRelayQuery'>;
}
declare module 'react-relay/lib/isClassicRelayContext.js' {
  declare module.exports: $Exports<'react-relay/lib/isClassicRelayContext'>;
}
declare module 'react-relay/lib/isClassicRelayEnvironment.js' {
  declare module.exports: $Exports<'react-relay/lib/isClassicRelayEnvironment'>;
}
declare module 'react-relay/lib/isCompatibleRelayFragmentType.js' {
  declare module.exports: $Exports<'react-relay/lib/isCompatibleRelayFragmentType'>;
}
declare module 'react-relay/lib/isPromise.js' {
  declare module.exports: $Exports<'react-relay/lib/isPromise'>;
}
declare module 'react-relay/lib/isRelayContainer.js' {
  declare module.exports: $Exports<'react-relay/lib/isRelayContainer'>;
}
declare module 'react-relay/lib/isRelayContext.js' {
  declare module.exports: $Exports<'react-relay/lib/isRelayContext'>;
}
declare module 'react-relay/lib/isRelayEnvironment.js' {
  declare module.exports: $Exports<'react-relay/lib/isRelayEnvironment'>;
}
declare module 'react-relay/lib/isRelayModernContext.js' {
  declare module.exports: $Exports<'react-relay/lib/isRelayModernContext'>;
}
declare module 'react-relay/lib/isRelayVariables.js' {
  declare module.exports: $Exports<'react-relay/lib/isRelayVariables'>;
}
declare module 'react-relay/lib/isScalarAndEqual.js' {
  declare module.exports: $Exports<'react-relay/lib/isScalarAndEqual'>;
}
declare module 'react-relay/lib/prettyStringify.js' {
  declare module.exports: $Exports<'react-relay/lib/prettyStringify'>;
}
declare module 'react-relay/lib/printRelayOSSQuery.js' {
  declare module.exports: $Exports<'react-relay/lib/printRelayOSSQuery'>;
}
declare module 'react-relay/lib/printRelayQuery.js' {
  declare module.exports: $Exports<'react-relay/lib/printRelayQuery'>;
}
declare module 'react-relay/lib/QueryBuilder.js' {
  declare module.exports: $Exports<'react-relay/lib/QueryBuilder'>;
}
declare module 'react-relay/lib/rangeOperationToMetadataKey.js' {
  declare module.exports: $Exports<'react-relay/lib/rangeOperationToMetadataKey'>;
}
declare module 'react-relay/lib/ReactRelayClassicExports.js' {
  declare module.exports: $Exports<'react-relay/lib/ReactRelayClassicExports'>;
}
declare module 'react-relay/lib/ReactRelayCompatContainerBuilder.js' {
  declare module.exports: $Exports<'react-relay/lib/ReactRelayCompatContainerBuilder'>;
}
declare module 'react-relay/lib/ReactRelayCompatPublic.js' {
  declare module.exports: $Exports<'react-relay/lib/ReactRelayCompatPublic'>;
}
declare module 'react-relay/lib/ReactRelayContainerProfiler.js' {
  declare module.exports: $Exports<'react-relay/lib/ReactRelayContainerProfiler'>;
}
declare module 'react-relay/lib/ReactRelayFragmentContainer-flowtest.js' {
  declare module.exports: $Exports<'react-relay/lib/ReactRelayFragmentContainer-flowtest'>;
}
declare module 'react-relay/lib/ReactRelayFragmentContainer.js' {
  declare module.exports: $Exports<'react-relay/lib/ReactRelayFragmentContainer'>;
}
declare module 'react-relay/lib/ReactRelayFragmentMockRenderer.js' {
  declare module.exports: $Exports<'react-relay/lib/ReactRelayFragmentMockRenderer'>;
}
declare module 'react-relay/lib/ReactRelayPaginationContainer-flowtest.js' {
  declare module.exports: $Exports<'react-relay/lib/ReactRelayPaginationContainer-flowtest'>;
}
declare module 'react-relay/lib/ReactRelayPaginationContainer.js' {
  declare module.exports: $Exports<'react-relay/lib/ReactRelayPaginationContainer'>;
}
declare module 'react-relay/lib/ReactRelayPropTypes.js' {
  declare module.exports: $Exports<'react-relay/lib/ReactRelayPropTypes'>;
}
declare module 'react-relay/lib/ReactRelayPublic.js' {
  declare module.exports: $Exports<'react-relay/lib/ReactRelayPublic'>;
}
declare module 'react-relay/lib/ReactRelayQueryRenderer.js' {
  declare module.exports: $Exports<'react-relay/lib/ReactRelayQueryRenderer'>;
}
declare module 'react-relay/lib/ReactRelayRefetchContainer-flowtest.js' {
  declare module.exports: $Exports<'react-relay/lib/ReactRelayRefetchContainer-flowtest'>;
}
declare module 'react-relay/lib/ReactRelayRefetchContainer.js' {
  declare module.exports: $Exports<'react-relay/lib/ReactRelayRefetchContainer'>;
}
declare module 'react-relay/lib/ReactRelayTypes.js' {
  declare module.exports: $Exports<'react-relay/lib/ReactRelayTypes'>;
}
declare module 'react-relay/lib/readRelayQueryData.js' {
  declare module.exports: $Exports<'react-relay/lib/readRelayQueryData'>;
}
declare module 'react-relay/lib/recycleNodesInto.js' {
  declare module.exports: $Exports<'react-relay/lib/recycleNodesInto'>;
}
declare module 'react-relay/lib/RelayCacheProcessor.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayCacheProcessor'>;
}
declare module 'react-relay/lib/RelayChangeTracker.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayChangeTracker'>;
}
declare module 'react-relay/lib/RelayClassicCore.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayClassicCore'>;
}
declare module 'react-relay/lib/RelayClassicRecordState.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayClassicRecordState'>;
}
declare module 'react-relay/lib/RelayCombinedEnvironmentTypes.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayCombinedEnvironmentTypes'>;
}
declare module 'react-relay/lib/RelayCompatContainer.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayCompatContainer'>;
}
declare module 'react-relay/lib/RelayCompatEnvironment.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayCompatEnvironment'>;
}
declare module 'react-relay/lib/RelayCompatMutations.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayCompatMutations'>;
}
declare module 'react-relay/lib/RelayCompatPaginationContainer.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayCompatPaginationContainer'>;
}
declare module 'react-relay/lib/RelayCompatRefetchContainer.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayCompatRefetchContainer'>;
}
declare module 'react-relay/lib/RelayCompatTypes.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayCompatTypes'>;
}
declare module 'react-relay/lib/RelayConcreteNode.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayConcreteNode'>;
}
declare module 'react-relay/lib/RelayConnectionInterface.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayConnectionInterface'>;
}
declare module 'react-relay/lib/RelayContainer.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayContainer'>;
}
declare module 'react-relay/lib/RelayContainerComparators.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayContainerComparators'>;
}
declare module 'react-relay/lib/RelayContainerProxy.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayContainerProxy'>;
}
declare module 'react-relay/lib/RelayContainerUtils.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayContainerUtils'>;
}
declare module 'react-relay/lib/RelayDefaultHandleKey.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayDefaultHandleKey'>;
}
declare module 'react-relay/lib/RelayDefaultNetworkLayer.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayDefaultNetworkLayer'>;
}
declare module 'react-relay/lib/RelayEnvironment.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayEnvironment'>;
}
declare module 'react-relay/lib/RelayEnvironmentSerializer.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayEnvironmentSerializer'>;
}
declare module 'react-relay/lib/RelayEnvironmentTypes.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayEnvironmentTypes'>;
}
declare module 'react-relay/lib/RelayError.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayError'>;
}
declare module 'react-relay/lib/RelayEventStatus.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayEventStatus'>;
}
declare module 'react-relay/lib/RelayFetchMode.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayFetchMode'>;
}
declare module 'react-relay/lib/RelayFragmentPointer.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayFragmentPointer'>;
}
declare module 'react-relay/lib/RelayFragmentReference.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayFragmentReference'>;
}
declare module 'react-relay/lib/RelayFragmentSpecResolver.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayFragmentSpecResolver'>;
}
declare module 'react-relay/lib/RelayGarbageCollection.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayGarbageCollection'>;
}
declare module 'react-relay/lib/RelayGarbageCollector.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayGarbageCollector'>;
}
declare module 'react-relay/lib/RelayGraphQLMutation.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayGraphQLMutation'>;
}
declare module 'react-relay/lib/RelayGraphQLTag.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayGraphQLTag'>;
}
declare module 'react-relay/lib/RelayInternals.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayInternals'>;
}
declare module 'react-relay/lib/RelayInternalTypes.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayInternalTypes'>;
}
declare module 'react-relay/lib/RelayMetaRoute.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayMetaRoute'>;
}
declare module 'react-relay/lib/RelayMetricsRecorder.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayMetricsRecorder'>;
}
declare module 'react-relay/lib/RelayMockRenderer.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayMockRenderer'>;
}
declare module 'react-relay/lib/RelayMutation.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayMutation'>;
}
declare module 'react-relay/lib/RelayMutationDebugPrinter.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayMutationDebugPrinter'>;
}
declare module 'react-relay/lib/RelayMutationQuery.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayMutationQuery'>;
}
declare module 'react-relay/lib/RelayMutationQueue.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayMutationQueue'>;
}
declare module 'react-relay/lib/RelayMutationRequest.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayMutationRequest'>;
}
declare module 'react-relay/lib/RelayMutationTracker.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayMutationTracker'>;
}
declare module 'react-relay/lib/RelayMutationTransaction.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayMutationTransaction'>;
}
declare module 'react-relay/lib/RelayMutationTransactionStatus.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayMutationTransactionStatus'>;
}
declare module 'react-relay/lib/RelayMutationType.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayMutationType'>;
}
declare module 'react-relay/lib/RelayNetworkDebug.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayNetworkDebug'>;
}
declare module 'react-relay/lib/RelayNetworkLayer.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayNetworkLayer'>;
}
declare module 'react-relay/lib/RelayNodeInterface.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayNodeInterface'>;
}
declare module 'react-relay/lib/RelayOperationSelector.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayOperationSelector'>;
}
declare module 'react-relay/lib/RelayOptimisticMutationUtils.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayOptimisticMutationUtils'>;
}
declare module 'react-relay/lib/RelayOSSConnectionInterface.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayOSSConnectionInterface'>;
}
declare module 'react-relay/lib/RelayPendingQueryTracker.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayPendingQueryTracker'>;
}
declare module 'react-relay/lib/RelayProfiler.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayProfiler'>;
}
declare module 'react-relay/lib/RelayPropTypes.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayPropTypes'>;
}
declare module 'react-relay/lib/RelayPublic.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayPublic'>;
}
declare module 'react-relay/lib/RelayQL.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayQL'>;
}
declare module 'react-relay/lib/RelayQuery.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayQuery'>;
}
declare module 'react-relay/lib/RelayQueryCaching.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayQueryCaching'>;
}
declare module 'react-relay/lib/RelayQueryConfig.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayQueryConfig'>;
}
declare module 'react-relay/lib/RelayQueryPath.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayQueryPath'>;
}
declare module 'react-relay/lib/RelayQueryRequest.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayQueryRequest'>;
}
declare module 'react-relay/lib/RelayQueryResultObservable.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayQueryResultObservable'>;
}
declare module 'react-relay/lib/RelayQueryTracker.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayQueryTracker'>;
}
declare module 'react-relay/lib/RelayQueryTransform.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayQueryTransform'>;
}
declare module 'react-relay/lib/RelayQueryVisitor.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayQueryVisitor'>;
}
declare module 'react-relay/lib/RelayQueryWriter.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayQueryWriter'>;
}
declare module 'react-relay/lib/RelayReadyState.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayReadyState'>;
}
declare module 'react-relay/lib/RelayReadyStateRenderer.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayReadyStateRenderer'>;
}
declare module 'react-relay/lib/RelayRecord.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayRecord'>;
}
declare module 'react-relay/lib/RelayRecordStatusMap.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayRecordStatusMap'>;
}
declare module 'react-relay/lib/RelayRecordStore.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayRecordStore'>;
}
declare module 'react-relay/lib/RelayRecordWriter.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayRecordWriter'>;
}
declare module 'react-relay/lib/RelayRefQueryDescriptor.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayRefQueryDescriptor'>;
}
declare module 'react-relay/lib/RelayRenderer.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayRenderer'>;
}
declare module 'react-relay/lib/RelayRootContainer.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayRootContainer'>;
}
declare module 'react-relay/lib/RelayRoute.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayRoute'>;
}
declare module 'react-relay/lib/RelayRouteFragment.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayRouteFragment'>;
}
declare module 'react-relay/lib/RelaySelector.js' {
  declare module.exports: $Exports<'react-relay/lib/RelaySelector'>;
}
declare module 'react-relay/lib/RelayShallowMock.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayShallowMock'>;
}
declare module 'react-relay/lib/RelayStore.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayStore'>;
}
declare module 'react-relay/lib/RelayStoreConstants.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayStoreConstants'>;
}
declare module 'react-relay/lib/RelayStoreData.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayStoreData'>;
}
declare module 'react-relay/lib/RelayTaskQueue.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayTaskQueue'>;
}
declare module 'react-relay/lib/RelayTypes.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayTypes'>;
}
declare module 'react-relay/lib/relayUnstableBatchedUpdates.js' {
  declare module.exports: $Exports<'react-relay/lib/relayUnstableBatchedUpdates'>;
}
declare module 'react-relay/lib/relayUnstableBatchedUpdates.native.js' {
  declare module.exports: $Exports<'react-relay/lib/relayUnstableBatchedUpdates.native'>;
}
declare module 'react-relay/lib/RelayVariable.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayVariable'>;
}
declare module 'react-relay/lib/RelayVariables.js' {
  declare module.exports: $Exports<'react-relay/lib/RelayVariables'>;
}
declare module 'react-relay/lib/restoreRelayCacheData.js' {
  declare module.exports: $Exports<'react-relay/lib/restoreRelayCacheData'>;
}
declare module 'react-relay/lib/serializeRelayQueryCall.js' {
  declare module.exports: $Exports<'react-relay/lib/serializeRelayQueryCall'>;
}
declare module 'react-relay/lib/simpleClone.js' {
  declare module.exports: $Exports<'react-relay/lib/simpleClone'>;
}
declare module 'react-relay/lib/splitDeferredRelayQueries.js' {
  declare module.exports: $Exports<'react-relay/lib/splitDeferredRelayQueries'>;
}
declare module 'react-relay/lib/stableJSONStringify.js' {
  declare module.exports: $Exports<'react-relay/lib/stableJSONStringify'>;
}
declare module 'react-relay/lib/stableStringify.js' {
  declare module.exports: $Exports<'react-relay/lib/stableStringify'>;
}
declare module 'react-relay/lib/testEditDistance.js' {
  declare module.exports: $Exports<'react-relay/lib/testEditDistance'>;
}
declare module 'react-relay/lib/throwFailedPromise.js' {
  declare module.exports: $Exports<'react-relay/lib/throwFailedPromise'>;
}
declare module 'react-relay/lib/toGraphQL.js' {
  declare module.exports: $Exports<'react-relay/lib/toGraphQL'>;
}
declare module 'react-relay/lib/transformRelayQueryPayload.js' {
  declare module.exports: $Exports<'react-relay/lib/transformRelayQueryPayload'>;
}
declare module 'react-relay/lib/validateMutationConfig.js' {
  declare module.exports: $Exports<'react-relay/lib/validateMutationConfig'>;
}
declare module 'react-relay/lib/validateRelayReadQuery.js' {
  declare module.exports: $Exports<'react-relay/lib/validateRelayReadQuery'>;
}
declare module 'react-relay/lib/writeRelayQueryPayload.js' {
  declare module.exports: $Exports<'react-relay/lib/writeRelayQueryPayload'>;
}
declare module 'react-relay/lib/writeRelayUpdatePayload.js' {
  declare module.exports: $Exports<'react-relay/lib/writeRelayUpdatePayload'>;
}
declare module 'react-relay/react-relay-classic.js' {
  declare module.exports: $Exports<'react-relay/react-relay-classic'>;
}
declare module 'react-relay/react-relay-classic.min.js' {
  declare module.exports: $Exports<'react-relay/react-relay-classic.min'>;
}
declare module 'react-relay/react-relay-compat.js' {
  declare module.exports: $Exports<'react-relay/react-relay-compat'>;
}
declare module 'react-relay/react-relay-compat.min.js' {
  declare module.exports: $Exports<'react-relay/react-relay-compat.min'>;
}
declare module 'react-relay/react-relay.js' {
  declare module.exports: $Exports<'react-relay/react-relay'>;
}
declare module 'react-relay/react-relay.min.js' {
  declare module.exports: $Exports<'react-relay/react-relay.min'>;
}
