# A step to collect proposals.
type CollectStep implements Node {
  # The ID of an object
  id: ID!
  proposals(
    # Returns the elements in the list that come after the specified cursor.
    after: String
    first: Int = 100

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the last `n` elements from the list.
    last: Int

    # If non-null, filters proposals with the given trashed status.
    trashedStatus: ProposalTrashedStatus = NOT_TRASHED

    # If non-null, filters proposals with the given district.
    district: ID

    # If non-null, filters proposals with the given type of author.
    userType: ID

    # If non-null, filters proposals with the given category.
    category: ID

    # If non-null, filters proposals with the given author.
    author: ID

    # If non-null, filters proposals with the given theme.
    theme: ID

    # If non-null, filters proposals with the given string to look for.
    term: String

    # Ordering options for proposals returned from the connection.
    orderBy: ProposalOrder = {field: PUBLISHED_AT, direction: ASC}
  ): ProposalConnection!

  # The title of the step.
  title: String!
}

# A consultation step
type ConsultationStep {
  # The ID of an object
  id: ID!

  # A list of contributor associated with the consultation step.
  contributors(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the first `n` elements from the list.
    first: Int = 100

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the last `n` elements from the list.
    last: Int
  ): UserConnection!

  # The number of votes in this consultation.
  votesCount: Int @deprecated(reason: "Field `votesCount` will be removed. Use `votes.totalCount` instead. In preparation for an upcoming change to the way we expose counters, this field will only be available inside a connection. Removal on 2019-09-01 UTC.")

  # Whether the user has vote for a contribution in this consultation step.
  userHasVote(
    # The user's login (for example, an email).
    login: String!
  ): Boolean!
}

# A string containing a datetime.
scalar DateTime

# A string containing an email.
scalar Email

# Represents a calendar event.
type Event implements Node & UniformResourceLocatable {
  # The ID of an object
  id: ID!

  # The URL to this resource.
  url: URI!

  # Identifies the date and time when the object was last updated.
  updatedAt: DateTime

  # Identifies the date and time when the object was created.
  createdAt: DateTime!

  # Identifies the author of the event.
  author: User

  # Identifies the title of the event.
  title: String!

  # Identifies the start of the event.
  startAt: DateTime

  # Identifies the end of the event.
  endAt: DateTime

  # Identifies the body of the event.
  body: HTML!

  # Identifies if the event is published.
  enabled: Boolean!

  # Identifies the latitude of the event.
  lat: Float

  # Identifies the longitude of the event.
  lng: Float

  # Identifies the registration link of the event.
  link: URI

  # Identifies the zip code of the event.
  zipCode: String

  # Identifies the address of the event.
  fullAddress: String
}

# A connection to a list of items.
type EventConnection {
  totalCount: Int!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination.
  edges: [EventEdge]
}

# An edge in a connection.
type EventEdge {
  # The item at the end of the edge.
  node: Event!

  # A cursor for use in pagination.
  cursor: String!
}

# A string containing HTML code.
scalar HTML

# A file uploaded by a user.
type Media implements UniformResourceLocatable {
  # The URL to this resource.
  url: URI!
}

# A question which accept document only.
type MediaQuestion implements Question {
  # The ID of an object
  id: ID!

  # Identifies the question title.
  title: String!

  # Return responses on this questions.
  responses(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the first `n` elements from the list.
    first: Int = 100

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the last `n` elements from the list.
    last: Int
  ): ResponseConnection!
}

# A media response.
type MediaResponse implements Response {
  # Nullable ID in case of empty response.
  id: String

  # The question.
  question: Question!

  # Identifies medias of the response.
  medias: [Media!]!
}

# A question with multiple choices available.
type MultipleChoiceQuestion implements Question {
  # The ID of an object
  id: ID!

  # Identifies the question title.
  title: String!

  # Return responses on this questions.
  responses(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the first `n` elements from the list.
    first: Int = 100

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the last `n` elements from the list.
    last: Int
  ): ResponseConnection!

  # The question available choices.
  choices: [QuestionChoice!]!
}

# Fetches an object given its ID
interface Node {
  # The ID of an object
  id: ID!
}

# Possible reason that a `Publishable` is not published.
enum NotPublishedReason {
  # Author account isn't confirmed yet.
  WAITING_AUTHOR_CONFIRMATION

  # Author account isn't confirmed and the step has ended.
  AUTHOR_NOT_CONFIRMED

  # Author account was confirmed after the step has ended.
  AUTHOR_CONFIRMED_TOO_LATE
}

# Possible directions in which to order a list of items when provided an orderBy argument.
enum OrderDirection {
  # Specifies an ascending order for a given orderBy argument.
  ASC

  # Specifies a descending order for a given orderBy argument.
  DESC
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String
}

interface PrivatableVote {
  # Whether the vote is anonymous or not.
  private: Boolean
}

# A participatory project.
type Project implements Node & UniformResourceLocatable {
  # The ID of an object
  id: ID!

  # The URL to this resource.
  url: URI!

  # Identifies the title of the project.
  title: String!

  # A list of votes associated with the project.
  votes(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the first `n` elements from the list.
    first: Int = 100

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the last `n` elements from the list.
    last: Int
  ): VoteConnection!

  # A list of contributors associated with the project.
  contributors(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the first `n` elements from the list.
    first: Int = 100

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the last `n` elements from the list.
    last: Int
  ): UserConnection!
}

# A connection to a list of items.
type ProjectConnection {
  totalCount: Int!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination.
  edges: [ProjectEdge]
}

# An edge in a connection.
type ProjectEdge {
  # The item at the end of the edge.
  node: Project!

  # A cursor for use in pagination.
  cursor: String!
}

# Ways in which project can be ordered.
input ProjectOrder {
  # The field in which to order nodes by.
  field: ProjectOrderField

  # The direction in which to order nodes.
  direction: OrderDirection
}

# Ordering projects.
enum ProjectOrderField {
  # Allows ordering a list of projects by there number of contributions.
  POPULAR

  # Allows ordering a list of projects by when they were published.
  LATEST
}

# Represents a user's contribution to a collect step.
type Proposal implements Node & Publishable & UniformResourceLocatable & Trashable {
  # The ID of an object
  id: ID!

  # Whether or not the entity is published.
  published: Boolean!

  # Identifies when the entity can no more be published.
  publishableUntil: DateTime

  # Identifies when the entity was published at.
  publishedAt: DateTime

  # Reason that the entity is not published.
  notPublishedReason: NotPublishedReason

  # The URL to this resource.
  url: URI!

  # Whether or not the contribution is trashed.
  trashed: Boolean!

  # Identifies the trashed visibility.
  trashedStatus: TrashableStatus

  # Identifies the moment the moderator trashed the contribution.
  trashedAt: DateTime

  # Identifies the reason why the moderator trashed the contribution.
  trashedReason: String

  # Identifies the date and time when the object was last updated.
  updatedAt: DateTime

  # Identifies the date and time when the object was created.
  createdAt: DateTime!

  # Identifies the proposal title.
  title: String!

  # Identifies the author of the contribution.
  author: User!

  # Identifies the body of the proposal.
  body: HTML

  # Identifies the responses of the proposal.
  responses: [Response]!

  # Identifies the unique reference of the proposal.
  reference: String!
}

# A connection to a list of items.
type ProposalConnection {
  totalCount: Int!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination.
  edges: [ProposalEdge]
}

# An edge in a connection.
type ProposalEdge {
  # The item at the end of the edge.
  node: Proposal!

  # A cursor for use in pagination.
  cursor: String!
}

# Ways in which proposal connections can be ordered.
input ProposalOrder {
  # The field in which to order nodes by.
  field: ProposalOrderField!

  # The direction in which to order nodes.
  direction: OrderDirection! = ASC
}

# Properties by which proposal connections can be ordered
enum ProposalOrderField {
  # Allows ordering a list of proposals by when they were created.
  PUBLISHED_AT

  # Allows ordering a list of proposals by the number of votes it have.
  VOTES

  # Allows ordering a list of proposals by the number of comments it have.
  COMMENTS

  # Allows randomizing a list of proposals.
  RANDOM

  # Allows ordering a list of proposals by the cost it have been estimated.
  COST
}

# Possible trashed status for a `Proposal`.
enum ProposalTrashedStatus {
  # `TRASHED` status to include the trashed proposal.
  TRASHED

  # `NOT_TRASHED` status to inclide the non trashed proposal.
  NOT_TRASHED
}

# A vote on a proposal for a given step.
type ProposalVote implements Publishable & Vote & PrivatableVote {
  # The ID of an object
  id: ID!

  # Whether or not the entity is published.
  published: Boolean!

  # Identifies when the entity can no more be published.
  publishableUntil: DateTime

  # Identifies when the entity was published at.
  publishedAt: DateTime

  # Reason that the entity is not published.
  notPublishedReason: NotPublishedReason

  # Whether the vote is anonymous or not.
  private: Boolean

  # Date of vote.
  createdAt: DateTime!

  # Is the vote anonymous ?
  anonymous: Boolean!
}

# Entities that can be published.
interface Publishable {
  # The ID of an object
  id: ID!

  # Whether or not the entity is published.
  published: Boolean!

  # Identifies when the entity can no more be published.
  publishableUntil: DateTime

  # Identifies when the entity was published at.
  publishedAt: DateTime

  # Reason that the entity is not published.
  notPublishedReason: NotPublishedReason
}

# Root of the schema.
type Query {
  # The currently authenticated user.
  viewer: User!

  # The ID of an object.
  node(
    # The ID of an object
    id: ID!
  ): Node

  # Lookup nodes by a list of IDs.
  nodes(
    # The list of node IDs.
    ids: [ID!]!
  ): [Node]!

  # Lookup projects.
  projects(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the first `n` elements from the list.
    first: Int = 100

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the last `n` elements from the list.
    last: Int

    # Ordering options for projects returning from the connection.
    orderBy: ProjectOrder = {field: LATEST, direction: DESC}

    # If non-null, projects with the given string to look for.
    term: String

    # If non-null, filter projects by statuses.
    status: ID

    # If non-null, filter projects by themes
    theme: ID

    # If non-null, filter projects by types
    type: ID

    # If non-null, filter projects by author
    author: ID

    # If true, filter projects with events
    withEventOnly: Boolean = false

    # If true, return only publics projects
    onlyPublic: Boolean = false
  ): ProjectConnection!

  # Lookup events.
  events(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the first `n` elements from the list.
    first: Int = 100

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the last `n` elements from the list.
    last: Int

    # If non-null, filters events by comparing the start date with present.
    isFuture: Boolean

    # If non-null, filters events with the given theme.
    theme: ID

    # If non-null, filters events with the given project.
    project: ID

    # If non-null, filters events with the given author.
    author: ID

    # If non-null, filters events with the given author type.
    userType: ID

    # If non-null, filters events with the given string to look for.
    search: String
  ): EventConnection!

  # Lookup users.
  users(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the first `n` elements from the list.
    first: Int = 100

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the last `n` elements from the list.
    last: Int
  ): UserConnection!
}

interface Question {
  # The ID of an object
  id: ID!

  # Identifies the question title.
  title: String!

  # Return responses on this questions.
  responses(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the first `n` elements from the list.
    first: Int = 100

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the last `n` elements from the list.
    last: Int
  ): ResponseConnection!
}

# A possible choice of a question.
type QuestionChoice {
  # The ID of an object.
  id: ID!

  # Identifies the question choice title.
  title: String!

  # Identifies the responses of the question choice.
  responses(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the first `n` elements from the list.
    first: Int = 100

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the last `n` elements from the list.
    last: Int
  ): ResponseConnection!
}

# A questionnaire is a series of questions that users can answer.
type Questionnaire implements Node {
  # The ID of an object
  id: ID!

  # Identifies the questionnaire title.
  title: String!

  # Whether the user has reply to a questionnaire.
  userHasReply(
    # The user's login (for example, an email).
    login: String!
  ): Boolean!

  # A list of users that have replied to the questionnaire.
  participants(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the first `n` elements from the list.
    first: Int = 100

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the last `n` elements from the list.
    last: Int
  ): UserConnection!

  # The list of questions of the questionnaire.
  questions: [Question!]!

  # A list of replies to the questionnaire.
  replies(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the first `n` elements from the list.
    first: Int = 100

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the last `n` elements from the list.
    last: Int
  ): ReplyConnection!
}

# Represents a user's answer to a questionnaire.
type Reply implements Node & Publishable {
  # The ID of an object
  id: ID!

  # Whether or not the entity is published.
  published: Boolean!

  # Identifies when the entity can no more be published.
  publishableUntil: DateTime

  # Identifies when the entity was published at.
  publishedAt: DateTime

  # Reason that the entity is not published.
  notPublishedReason: NotPublishedReason

  # Identifies the date and time when the object was last updated.
  updatedAt: DateTime

  # Identifies the date and time when the object was created.
  createdAt: DateTime!

  # The responses of the reply.
  responses: [Response]!

  # The author of the contribution.
  author: User!
}

# A connection to a list of items.
type ReplyConnection {
  # Identifies the total count of items in the connection.
  totalCount: Int!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination.
  edges: [ReplyEdge]
}

# An edge in a connection.
type ReplyEdge {
  # The item at the end of the edge.
  node: Reply!

  # A cursor for use in pagination.
  cursor: String!
}

# A response to a question.
interface Response {
  # Nullable ID in case of empty response.
  id: String

  # The question.
  question: Question!
}

# A connection to a list of items.
type ResponseConnection {
  # Identifies the total count of items in the connection.
  totalCount: Int!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination.
  edges: [ResponseEdge]
}

# An edge in a connection.
type ResponseEdge {
  # The item at the end of the edge.
  node: Response!

  # A cursor for use in pagination.
  cursor: String!
}

# A section is just a title in a quiz without any possible answer.
type SectionQuestion implements Question {
  # The ID of an object
  id: ID!

  # Identifies the question title.
  title: String!

  # Return responses on this questions.
  responses(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the first `n` elements from the list.
    first: Int = 100

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the last `n` elements from the list.
    last: Int
  ): ResponseConnection!
}

# A simple question
type SimpleQuestion implements Question {
  # The ID of an object
  id: ID!

  # Identifies the question title.
  title: String!

  # Return responses on this questions.
  responses(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the first `n` elements from the list.
    first: Int = 100

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the last `n` elements from the list.
    last: Int
  ): ResponseConnection!
}

# Entities that can be trashed.
interface Trashable {
  # Whether or not the contribution is trashed.
  trashed: Boolean!

  # Identifies the trashed visibility.
  trashedStatus: TrashableStatus

  # Identifies the moment the moderator trashed the contribution.
  trashedAt: DateTime

  # Identifies the reason why the moderator trashed the contribution.
  trashedReason: String
}

# Different trashable status.
enum TrashableStatus {
  # Content is not visible.
  INVISIBLE

  # Content is visible.
  VISIBLE
}

# An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string.
scalar URI

# Represents a type that can be retrieved by a URL.
interface UniformResourceLocatable {
  # The URL to this resource.
  url: URI!
}

# A user is an individual's account.
type User implements Node & UniformResourceLocatable {
  # The ID of an object
  id: ID!

  # The URL to this resource.
  url: URI!

  # The user's public name.
  username: String

  # Whether or not this user is the authenticated user.
  isViewer: Boolean!

  # Identifies the date and time when the object was created.
  createdAt: DateTime!

  # Identifies the date and time when the object was last updated.
  updatedAt: DateTime

  # A URL pointing to the user's Facebook account.
  facebookUrl: URI

  # A URL pointing to the user's Twitter account.
  twitterUrl: URI

  # A URL pointing to the user's LinkedIn account.
  linkedInUrl: URI

  # A URL pointing to the user's public website/blog.
  websiteUrl: URI

  # The user's public profile biography.
  biography: String

  # Identifies the date and time when this user account was deleted.
  deletedAccountAt: DateTime

  # The type of the person.
  userType: UserType

  # The responses answered by user.
  responses(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the first `n` elements from the list.
    first: Int = 100

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the last `n` elements from the list.
    last: Int
  ): ResponseConnection!

  # The user's personal email.
  email: Email

  # Whether or not this user consent internal communication.
  consentInternalCommunication: Boolean

  # The user's public avatar URL.
  avatarUrl: URI

  # Whether or not this user has a confirmed account.
  enabled: Boolean!
}

# A connection to a list of items.
type UserConnection {
  # Identifies the total count of items in the connection.
  totalCount: Int!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination.
  edges: [UserEdge]
}

# An edge in a connection.
type UserEdge {
  # The item at the end of the edge.
  node: User!

  # A cursor for use in pagination.
  cursor: String!
}

# A type of person
type UserType {
  id: ID!

  # The name of the type.
  name: String!
}

# A value response.
type ValueResponse implements Response {
  # Nullable ID in case of empty response.
  id: String

  # The question.
  question: Question!

  # The response value which can be a string or a JSON.
  value: String

  # The response value formatted.
  formattedValue: String
}

# A vote.
interface Vote {
  # The ID of an object
  id: ID!

  # Date of vote.
  createdAt: DateTime!
}

# A connection to a list of items.
type VoteConnection {
  totalCount: Int!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Information to aid in pagination.
  edges: [VoteEdge]
}

# An edge in a connection.
type VoteEdge {
  # The item at the end of the edge.
  node: Vote

  # A cursor for use in pagination.
  cursor: String!
}
